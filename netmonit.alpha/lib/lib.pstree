#!/bin/bash


##	 Usefull own filter of pstree if you want have exit status from pstree (part of psmisc 23.3-1)


#============================================================================{
PROC.OF.PSTREE_2() {
#		This is instead of command "pstree -spa"

if [ -z "$PS_TREE" ] ; then echo "Error: variable PS_TREE is empty." ; exit 1 ; fi
if [ -z "$PID" ]     ; then echo "Error: variable PID is empty." ; exit 1 ; fi

#echo "=========="
#echo "PID = $PID"

# For Part Above of lines
KOLUMN=0 ;
OLD_NUMBER_CHARS=0
# For Part Below
BREAK=0

while IFS=',' read -r COLUMNS_AND_NAME  PID_AND_ARGUMENTS ; do

	LINE="${COLUMNS_AND_NAME} ${PID_AND_ARGUMENTS}"

	##	== Part Above of lines =={
	#	if first line ; then
	if [[ "$OLD_NUMBER_CHARS" -eq "0" ]] ; then
		OLD_NUMBER_CHARS="1" 
		TAB_ABOVE[$KOLUMN]="$LINE"
	#	if not Part Bellow
	elif [[ "$BREAK" == "0" ]] ; then
		# divide "$COLUMNS_AND_NAME"
		while IFS='-' read -r SOME_CHARS  PROCESS_NAME ; do
			NUMBER_CHARS="${#SOME_CHARS}"

			# For Debug
			#echo "LINE:$LINE"
			#echo "NUMBER_CHARS = $NUMBER_CHARS ; OLD_NUMBER_CHARS = $OLD_NUMBER_CHARS"
		
			# if next tree
			if [[ "$NUMBER_CHARS" -gt "$OLD_NUMBER_CHARS" ]] ; then
				KOLUMN="$[$KOLUMN + 1]"
				TAB3[$KOLUMN]="$NUMBER_CHARS"  ;
				TAB_ABOVE[$KOLUMN]="$LINE"  ;

			# if the same tree
			elif [[ "$NUMBER_CHARS" -eq "$OLD_NUMBER_CHARS" ]] ; then
				KOLUMN="$KOLUMN"
				TAB3[$KOLUMN]="$NUMBER_CHARS"
				TAB_ABOVE[$KOLUMN]="$LINE"  ;

			# if one of the earlier tree
			elif [[ "$NUMBER_CHARS" -lt "$OLD_NUMBER_CHARS" ]] ; then
				COUNT_LOCAL=1
				##	DEBUG:
				#echo "TAB3 before TAB3_NUMBER loop: ${TAB3[@]}"
				
				for TAB3_NUMBER in "${TAB3[@]}" ; do
					if   [[ "$TAB3_NUMBER" -eq "$NUMBER_CHARS" ]] ; then
						break
					elif [[ "$TAB3_NUMBER" -gt "$NUMBER_CHARS" ]] ; then
						break
					fi
					COUNT_LOCAL=$[$COUNT_LOCAL + 1]
					#echo "TAB3_NUMBER=$TAB3_NUMBER"
					#echo "COUNT_LOCAL=$COUNT_LOCAL"
				done

				KOLUMN=$COUNT_LOCAL
				TAB3[$KOLUMN]="$NUMBER_CHARS"
				TAB_ABOVE[$KOLUMN]="$LINE"  ;

				#echo "Before loop: $[$COUNT_LOCAL + 1] ; ${#TAB3[@]}"
				#echo "=========={"
				#printf "%s\n" "${TAB_ABOVE[@]::${#TAB_ABOVE[@]}-1}"
				#echo "==========}"

				#echo " BEFORE NUMBER_M: $[$COUNT_LOCAL + 1] ; ${#TAB3[@]} "

				# Remove older from TAB3
				##	 We need use while loop instead for loop + seq ( because it can be interpreted with and without quotation marks )
				#for M in  $( seq $[$COUNT_LOCAL + 1] ${#TAB3[@]} ) ; do
				NUMBER_M="$COUNT_LOCAL"
				while [ $NUMBER_M -le ${#TAB3[@]} ] ; do
					## For Debug
					if [[ $(wc -l <<< "$NUMBER_M") -gt 1 ]] ;then
						echo "Error: element NUMBER_M have more lines than 1."
						echo "Debugging: NUMBER_M = $NUMBER_M"
					fi

					##	remove from TAB3
					unset TAB3[$NUMBER_M]
					unset TAB_ABOVE[$NUMBER_M]

					## refresh counting 
					NUMBER_M=$[$NUMBER_M+1]
				done

				#echo "==== After loop ===={"
				#printf "%s\n" "${TAB_ABOVE[@]::${#TAB_ABOVE[@]}-1}"
				#echo "====================}"
			fi

			OLD_NUMBER_CHARS="$NUMBER_CHARS"
		done <<< "$COLUMNS_AND_NAME"
	fi


	##	== Part Center of lines ==
	#F.PART.CENTER
	while IFS=' ' read -r PID_LINE OPTIONS ; do
		#echo "PID_LINE = $PID_LINE"
		if [[ "$PID_LINE" -eq "$PID" ]] ; then

					## For Debug
					#echo "===BEFORE 1 SET $COLUMNS_AND_NAME ; $CHARS ; $1 ================{"

			PART_CENTER="$LINE"
			BREAK=1
			IFS="-"; set $COLUMNS_AND_NAME ; CHARS="$1" ; SAVE_NUMBER_CHARS=${#CHARS}
			COUNT_PART_BELOW=0

					#echo "===AFTER 1 SET $COLUMNS_AND_NAME ; $CHARS ; $1 =================}"
			break
		fi
	done <<< "$PID_AND_ARGUMENTS"

	# Trick for Part Below
	if [[ "$BREAK" == "1" ]] ; then
		BREAK=2
		continue
	fi

	##	== Part Below of lines ==
	#F.PART.BELOW
	if [[ "$BREAK" == "2" ]] ; then

				# For Debug: tree signs have been replaced with the number of these characters
				#echo "===BEFORE 2 SET ${#COLUMNS_AND_NAME} ; ${#CHARS} ; ${#1} =========={" 
		##	Bash remember last while settings, so we restore the main settings 
		IFS="-"; set $COLUMNS_AND_NAME ; CHARS="$1" ; NUMBER_CHARS=${#CHARS}
				#echo "===AFTER 2 SET ${#COLUMNS_AND_NAME} ; ${#CHARS} ; ${#1}  ==========}" 

		# For Debug
		#echo "Part Below:"
		#echo "$LINE"
		#echo "CHARS=$CHARS"
		#echo " SAVE ; NEW = $SAVE_NUMBER_CHARS ; $NUMBER_CHARS"
		
		if [[ "$NUMBER_CHARS" -le "$SAVE_NUMBER_CHARS" ]] ;then
			#echo "Smaler or equal"
			break
		fi

		PART_BELOW[$COUNT_PART_BELOW]="$LINE"
		COUNT_PART_BELOW=$[$COUNT_PART_BELOW + 1]
		#echo "COUNT_PART_BELOW: ${COUNT_PART_BELOW[@]}"
	fi

	#echo "spam wwww"
done <<< "$PS_TREE"
#
#echo "=========={"
#printf "%s\n" "${TAB_ABOVE[@]::${#TAB_ABOVE[@]}-1}"
#echo "==========--"
#printf "%s\n" "${PART_CENTER}"
#echo "==========--"
#printf "%s\n" "${PART_BELOW[@]}"
#echo "==========}"

if [ ! -z "${PART_CENTER}" ] ; then
	PROC_PSTREE_OUT=$(printf "%s\n" "${TAB_ABOVE[@]::${#TAB_ABOVE[@]}-1}" "${PART_CENTER}" "${PART_BELOW[@]}")

	##	DEBUG:
	#echo "== PROC_PSTREE_OUT =={"
	#echo "$PROC_PSTREE_OUT"
	#echo "== PROC_PSTREE_OUT ==}"
fi

if [ -z "$PROC_PSTREE_OUT" ] ; then 
	echo "Error: variable PROC_PSTREE_OUT is empty." ;
	echo "PID = $PID"
fi
}
#============================================================================}


